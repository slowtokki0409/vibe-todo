# Nexus Protocol v1.2 vs v2.0 비교 가이드

**작성자**: Claude Code
**날짜**: 2026-01-14
**목적**: AG님이 쉽게 이해할 수 있도록 버전 간 차이를 실생활 비유로 설명

---

## 🎬 실생활 비유: 영화 제작 방식의 변화

### v1.2 = "프리랜서 감독 시대"
한 명의 감독(Claude)이 모든 것을 순차적으로 처리:
- 시나리오 받기 → 촬영 → 편집 → 음악 → 검토 요청 → 다시 편집...
- 매 단계마다 제작자(AG)에게 "이거 괜찮나요?" 확인

### v2.0 = "할리우드 스튜디오 시스템"
전문가 팀(Squad)이 동시에 작업:
- 시나리오 분석 → **동시 진행**: 촬영팀 + 음악팀 + 편집팀
- 제작자에게는 "완성본" 시사회만 보여줌
- 중간 과정 보고 없이 결과만 전달

---

## 📊 핵심 차이 비교표

| 항목 | v1.2 (구버전) | v2.0 (신버전) |
|:---|:---|:---|
| **작업 방식** | 🐌 순차 작업 (한 번에 하나씩) | ⚡ 병렬 작업 (동시 다발적) |
| **인력 구조** | 👤 1인 프리랜서 | 👥 전문가 팀 (Squad) |
| **의사소통** | 💬 매번 확인 요청 | 🎯 결과만 보고 |
| **입력 방식** | 📝 텍스트 지시만 | 🌐 텍스트 + URL + 동영상 |
| **설명 방식** | 🤖 기술 용어 (API, Hook...) | 🧑‍🏫 실생활 비유 (식당, 노트북...) |
| **속도** | 🚶‍♂️ 느림 (핑퐁 대화) | 🚀 빠름 (Batch 실행) |
| **역할** | 수동적 조수 | 자율적 팀원 |

---

## 🏗️ 구체적 변화 설명

### 1️⃣ 작업 방식: 순차 → 병렬

#### v1.2 방식 (순차):
```
[AG] "로그인 페이지 만들어줘"
[CC] "로그인 폼 만들었어요, 확인해주세요"
[AG] "좋아, 다음 할 일은?"
[CC] "비밀번호 찾기 버튼 추가했어요, 확인해주세요"
[AG] "좋아, 다음은?"
...반복...
```
**비유**: 요리사가 하나씩 요리하고 매번 맛을 보여줌

#### v2.0 방식 (병렬):
```
[AG] "로그인 페이지 만들어줘"
[CC] (내부에서 3-5개 작업 동시 실행)
      - 로그인 폼 생성
      - 비밀번호 찾기 추가
      - 에러 메시지 처리
      - 스타일링 적용
      - 테스트 완료
[CC] "완성했습니다. 결과물 확인해주세요 → [스크린샷]"
```
**비유**: 요리사가 코스 요리를 한 번에 준비해서 완성된 테이블만 보여줌

---

### 2️⃣ 인력 구조: 1인 → Squad (팀)

#### v1.2 (1인 프리랜서):
```
Claude 혼자 모든 역할 수행:
- 기획도 하고
- 코딩도 하고
- 디자인도 하고
- 테스트도 하고
```
**비유**: 1인 밴드 (모든 악기를 혼자 연주)

#### v2.0 (Squad 시스템):
```
상황에 따라 전문가 팀 구성:

[빠른 작업]: Rapid Proto Squad
  - Frontend_Blue (리드): 디자인+코딩 전담
  - Reviewer_Red (지원): 최종 점검만

[복잡한 작업]: Deep Tech Squad
  - System_Architect: 설계도 작성
  - Frontend_Dev: UI 구현 (병렬)
  - Backend_Dev: API 구현 (병렬)
  - QA_Engineer: 통합 테스트
```
**비유**: 오케스트라 (각자 전문 악기 연주, 지휘자가 조율)

---

### 3️⃣ 의사소통: 확인 요청 → 결과 보고

#### v1.2 스타일:
```
[CC] "파일 A 수정했습니다"
[AG] "확인했어"
[CC] "파일 B 수정했습니다"
[AG] "확인했어"
[CC] "파일 C 수정했습니다"
[AG] "확인했어"
```
**문제점**: 5번 대화 → 5분 소요

#### v2.0 스타일:
```
[CC] (조용히 A, B, C, D, E 파일 모두 수정)
[CC] "로그인 기능 완성했습니다"
     - 증거: _artifacts/screenshot.png
     - 테스트: 모두 통과
     - 다음: 회원가입 기능 진행할까요?
```
**장점**: 1번 대화 → 1분 소요

**비유**:
- v1.2 = 건축 중에 매일 사장님 방문 (비효율)
- v2.0 = 준공 후 한 번만 방문 (효율)

---

### 4️⃣ 입력 방식: 텍스트 → 멀티 소스

#### v1.2 입력:
```
[AG] "Uber같은 앱 만들어줘"
[CC] "어떤 기능이 필요한가요?"
[AG] "사용자 등록, 예약, 결제..."
...긴 대화...
```

#### v2.0 입력:
```
[AG] "이 YouTube 보고 똑같이 만들어줘"
     → https://youtube.com/watch?v=uber-demo

[CC] (자동으로 비디오 분석)
     "이해했습니다:
     - 사용자 앱 (승객용)
     - 기사 앱
     - 실시간 매칭
     - 결제 시스템
     이렇게 만들까요?"
```

**지원 형식**:
- ✅ 자연어 ("강아지 산책 전용 우버 만들어줘")
- ✅ Markdown 문서
- ✅ PDF 기획서
- ✅ **YouTube 영상** ⭐
- ✅ **웹사이트 URL** ⭐
- ✅ **블로그 포스트** ⭐

**비유**:
- v1.2 = 음성으로만 주문 (시간 오래 걸림)
- v2.0 = 사진 보여주고 주문 (빠르고 정확)

---

### 5️⃣ 설명 방식: 기술 용어 → 실생활 비유 (Feynman Rule)

#### v1.2 설명 스타일:
```
[CC] "REST API endpoint를 구현했고,
     JWT 토큰으로 authentication을 처리하며,
     React Hook의 useEffect로 state를 관리합니다"

[AG] "...뭐라는 거야?" 😵
```

#### v2.0 설명 스타일 (Feynman Rule):
```
[CC] Technical: "REST API with JWT auth implemented"

     User 설명:
     "식당 시스템으로 비유하면:
     - API = 웨이터 (주문 받고 음식 나름)
     - JWT 토큰 = 회원 카드 (신원 확인)
     - React Hook = 주문 메모장 (상태 기억)

     → 로그인하면 '회원 카드'를 받고,
       버튼 누르면 '웨이터'가 데이터 가져옴"

[AG] "아 이해했어!" 😊
```

**핵심**: 전문 용어 없이 실생활 비유로 설명

---

## 🎯 실제 사용 시나리오 비교

### 시나리오: "할일 관리 앱에 알림 기능 추가해줘"

#### v1.2 프로세스:
```
1. [CC] "알림 컴포넌트 만들었어요"
2. [AG] "확인, 다음은?"
3. [CC] "알림 로직 추가했어요"
4. [AG] "확인, 다음은?"
5. [CC] "스타일 적용했어요"
6. [AG] "확인, 다음은?"
7. [CC] "테스트 완료했어요"
8. [AG] "보여줘"
9. [CC] "스크린샷입니다"

소요 시간: 9번 대화, 약 15분
```

#### v2.0 프로세스:
```
1. [AG] "할일 앱에 알림 기능 추가해줘"

2. [CC] (내부 실행 - 보고 없음)
        - NotificationBanner 컴포넌트 생성
        - 알림 로직 utils/notifications.js에 추가
        - App.jsx 통합
        - 글래스모피즘 스타일 적용
        - 테스트 실행

3. [CC] "✅ 알림 기능 완성했습니다!

        만든 것:
        - 브라우저 알림 권한 요청 배너
        - 1시간 전 긴급 알림
        - 알림 중복 방지 시스템

        증거: _artifacts/notification_proof.png

        실생활 비유:
        → '리마인더 앱'처럼 중요한 할일 1시간 전에
          핸드폰 알림으로 알려드립니다

        다음: 반복 할일 기능도 추가할까요?"

소요 시간: 2번 대화, 약 3분
```

**효율성 차이**: 5배 빠름 ⚡

---

## 🚀 속도 비교 (체감 속도)

| 작업 | v1.2 | v2.0 | 개선 |
|:---|:---:|:---:|:---:|
| **간단한 기능 추가** | 10분 | 2분 | 5배 ⚡ |
| **중간 크기 페이지** | 30분 | 5분 | 6배 ⚡ |
| **복잡한 SaaS 기능** | 2시간 | 20분 | 6배 ⚡ |

**비유**:
- v1.2 = 버스 (정류장마다 멈춤)
- v2.0 = 고속철도 (목적지까지 직행)

---

## 🎨 품질 기준 변화

### v1.2:
```
"작동하면 됐어" ✅ → 완료
```

### v2.0:
```
"작동하면서 예뻐야 돼" ✅✨ → 완료

Golden Rule 4: "Vibe is Non-Negotiable"
→ 못생긴 코드 = 실패
```

**비유**:
- v1.2 = 대학생 과제 (기능만 있으면 됨)
- v2.0 = 애플 제품 (기능 + 디자인 필수)

---

## 🧠 AG와 CC의 역할 변화

### v1.2 관계:
```
AG (관리자) ──지시──> CC (직원)
                     ↑
                    확인
```
**비유**: 상사와 신입사원 (마이크로 매니징)

### v2.0 관계:
```
AG (건축가)
  ↓ 비전 제시
CC (건설 팀장)
  ↓ 자율 실행
[Squad] (전문가들)
```
**비유**: 건축가와 시공 책임자 (신뢰 기반 위임)

---

## 📋 체크리스트: 내가 v2.0을 제대로 쓰고 있나?

### ✅ v2.0 올바른 사용:
- [ ] 한 번에 3개 이상 파일 수정하는가?
- [ ] 중간 과정 보고 없이 결과만 받는가?
- [ ] URL 보내서 "이거 분석해서 만들어"라고 하는가?
- [ ] 설명 들을 때 기술 용어 없이 이해되는가?
- [ ] 작업 속도가 이전보다 5배 빠른가?

### ❌ 아직 v1.2 습관:
- [ ] "이 파일 수정했어요" → "확인" 반복
- [ ] 기능마다 일일이 지시
- [ ] 긴 텍스트로 기획서 작성
- [ ] "API가 뭐예요?" 같은 질문 필요
- [ ] 느리고 답답함

---

## 🎯 결론: 한 줄 요약

### v1.2:
> "시키는 대로 하는 조수"

### v2.0:
> "알아서 척척하는 팀"

---

**실생활 최종 비유**:

```
v1.2 = 레고 조립 설명서 (한 단계씩 확인)
v2.0 = 3D 프린터 (설계도만 주면 알아서 완성)
```

---

**AG님, 이제 v2.0의 힘을 체감하실 준비가 되셨습니다!** 🚀
